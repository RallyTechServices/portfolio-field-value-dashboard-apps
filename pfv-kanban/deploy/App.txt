<!DOCTYPE html>
<html>
<head>
    <title>Portfolio Kanban</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Tue Feb 23 2016 07:56:50 GMT-0700 (MST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Tue Feb 23 2016 07:56:50 GMT-0700 (MST)";
        var CHECKSUM = 45949579760;
    </script>
    
    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
Ext.define('Rally.technicalservices.common.DashboardFilter',{


    filterModelType: undefined,
    filterField: undefined,
    filterValue: undefined,

    getFilter: function(resultsRecordType, portfolioItemTypes){

        portfolioItemTypes = portfolioItemTypes || [];
        resultsRecordType = resultsRecordType || this.filterModelType;

        var modelType = this.filterModelType.toLowerCase(),
            pi_types = portfolioItemTypes.length > 0 ? _.map(portfolioItemTypes, function(pi){return pi.typePath.toLowerCase()}) : [],
            idx = _.indexOf(pi_types, modelType),
            type_idx = _.indexOf(pi_types, resultsRecordType.toLowerCase());
        console.log('idx', idx,type_idx);
        if (type_idx < idx) {
            var properties = [];
            for (var i = type_idx; i < idx; i++) {
                if (i < 0) {
                    properties.push("PortfolioItem");
                } else {
                    properties.push('Parent');
                }
            }
            properties.push(this._getFilterFieldProperty())
            return Ext.create('Rally.data.wsapi.Filter', {
                property: properties.join('.'),
                value: this.filterValue
            });
        } else if (type_idx === idx){
            return Ext.create('Rally.data.wsapi.Filter', {
                property: this._getFilterFieldProperty(),
                value:this.filterValue
            });
        } else {
            return null;
        }
    },
    _getFilterFieldProperty: function(){
        //if (Rally.technicalservices.common.DashboardFilter.referenceFieldAttributes[this.filterField]){
        //    return this.filterField + '.' + Rally.technicalservices.common.DashboardFilter.referenceFieldAttributes[this.filterField];
        //}
        return this.filterField;
    },
    statics: {
        publishedEventName: 'dashboardFilterUpdated',
        requestEventName: 'requestDashboardFilter'
    }
});

Ext.define('Rally.technicalservices.WsapiToolbox', {
    singleton: true,
    fetchWsapiCount: function(model, query_filters){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: ['ObjectID'],
            filters: query_filters,
            limit: 1,
            pageSize: 1
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} count for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchModelTypePathByTypeDefinition: function(typeDef){
        var deferred = Ext.create('Deft.Deferred');
        var typeDefId = 0;
        if (typeDef){
            typeDefId = typeDef.replace('/typedefinition/','');
        }

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: 'TypeDefinition',
            fetch: ['TypePath','Name'],
            filters: [{
                property: 'ObjectID',
                value: typeDefId
            }]
        }).load({
            callback: function(records, operation, success){
                if (success && records && records.length > 0){
                    deferred.resolve(records[0].get('TypePath'));
                } else {
                    deferred.resolve(null); //(Ext.String.format("Error getting TypeDefinition for {1}: {0}", operation.error.errors.join(','), typeDef));
                }
            }
        });
        return deferred;
    },
    fetchWsapiRecords: function(model, query_filters, fetch_fields, context){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: fetch_fields,
            filters: query_filters,
            context: context,
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchReleases: function(timebox){

        var deferred = Ext.create('Deft.Deferred'),
            rec = timebox.getRecord(),
            me = this;

        if (rec === null) {
            deferred.resolve([]);
        }

        Ext.create('Rally.data.wsapi.Store',{
            model: 'Release',
            fetch: ['ObjectID'],
            filters: [{
                property: 'Name',
                value: rec.get('Name')
            },{
                property: 'ReleaseStartDate',
                value: rec.get('ReleaseStartDate')
            },{
                property: 'ReleaseDate',
                value: rec.get('ReleaseDate')
            }],
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                }   else {
                    deferred.reject("Error loading Releases: " + operation.error.errors.join(','));
                }
            }
        });
        return deferred;
    },

    fetchAllowedValues: function(model,field_name) {
        var deferred = Ext.create('Deft.Deferred');

        Rally.data.ModelFactory.getModel({
            type: model,
            success: function(model) {
                model.getField(field_name).getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        var values = Ext.Array.map(records, function(record) {
                            return record.get('StringValue');
                        });
                        deferred.resolve(values);
                    }
                });
            },
            failure: function(msg) { deferred.reject('Error loading field values: ' + msg); }
        });
        return deferred;
    },
    fetchPortfolioItemTypes: function(){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store', {
            model: 'TypeDefinition',
            fetch: ['TypePath', 'Ordinal','Name'],
            filters: [{
                property: 'TypePath',
                operator: 'contains',
                value: 'PortfolioItem/'
            }],
            sorters: [{
                property: 'Ordinal',
                direction: 'ASC'
            }]
        });
        store.load({
            callback: function(records, operation, success){
                if (success){
                    var portfolioItemTypes = new Array(records.length);
                    _.each(records, function(d){
                        //Use ordinal to make sure the lowest level portfolio item type is the first in the array.
                        var idx = Number(d.get('Ordinal'));
                        portfolioItemTypes[idx] = { typePath: d.get('TypePath'), name: d.get('Name') };
                        //portfolioItemTypes.reverse();
                    });
                    deferred.resolve(portfolioItemTypes);
                } else {
                    var error_msg = '';
                    if (operation && operation.error && operation.error.errors){
                        error_msg = operation.error.errors.join(',');
                    }
                    deferred.reject('Error loading Portfolio Item Types:  ' + error_msg);
                }
            }
        });
        return deferred.promise;
    },
    fetchDoneStates: function(){
        var deferred = Ext.create('Deft.Deferred');
        Rally.data.ModelFactory.getModel({
            type: 'HierarchicalRequirement',
            success: function(model) {
                var field = model.getField('ScheduleState');
                field.getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        if (success){
                            var values = [];
                            for (var i=records.length - 1; i > 0; i--){
                                values.push(records[i].get('StringValue'));
                                if (records[i].get('StringValue') == "Accepted"){
                                    i = 0;
                                }
                            }
                            deferred.resolve(values);
                        } else {
                            deferred.reject('Error loading ScheduleState values for User Story:  ' + operation.error.errors.join(','));
                        }
                    },
                    scope: this
                });
            },
            failure: function() {
                var error = "Could not load schedule states";
                deferred.reject(error);
            }
        });
        return deferred.promise;
    },
    fetchTypeDefinition: function(typePath){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: 'TypeDefinition',
            fetch: ['TypePath','Name'],
            filters: [{
                property: 'TypePath',
                value: typePath
            }]
        }).load({
            callback: function(records, operation, success){
                if (success && records && records.length > 0){
                    deferred.resolve(records[0]);
                } else {
                    var message = "No records returned when loading Type Definition for " + typePath;
                    if (!success){
                        message = "Error loading Type Definition for " + typePath + ':  ' + operation.error.errors.join(',');
                    }
                    deferred.reject(message); //(Ext.String.format("Error getting TypeDefinition for {1}: {0}", operation.error.errors.join(','), typeDef));
                }
            }
        });
        return deferred;
    }
});

(function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.app.plugin.GridBoardAppResizer', {
        alias: 'plugin.rallygridboardappresizer',
        extend: 'Ext.AbstractPlugin',

        init: function (cmp) {
            this.cmp = cmp;

            cmp.on('contentupdated', function () {
                if (!this.cmp.isDestroyed) {
                    this._sizeGridBoardsToPage();

                    if (!this._listenerAdded) {
                        this._listenerAdded = true;
                        Ext.EventManager.onWindowResize(this._sizeGridBoardsToPage, this);
                    }
                }
            }, this);

            cmp.on('destroy', function () {
                if (this._listenerAdded) {
                    Ext.EventManager.removeResizeListener(this._sizeGridBoardsToPage, this);
                }
            }, this);
        },

        _getFooterHeight: _.memoize(function () {
            var footerContainerEl = Ext.get(Ext.query('.footer-container')[0]);
            return (footerContainerEl && footerContainerEl.getHeight()) || 0;
        }),

        _getTotalParentBottomPadding: _.memoize(function () {
            var el = this.cmp.getEl();
            var totalBottomPadding = 0;

            while(el && el.id !== 'content') {
                totalBottomPadding += el.getPadding('b') + el.getBorderWidth('b');
                el = el.parent();
            }

            return totalBottomPadding;
        }),

        _sizeGridBoardsToPage: function () {
            var gridboards = this.cmp.query('rallygridboard');

            if (gridboards.length) {
                var appTop = this.cmp.getEl().getTop();
                var availableHeight = this.cmp.getHeight();
                var minHeight = availableHeight;
                var windowHeight = Rally.util.Window.getHeight();

                if (this.cmp.isFullPageApp) {
                    availableHeight = windowHeight - appTop - this._getFooterHeight() - this._getTotalParentBottomPadding() - 3;
                    minHeight = (600 - (windowHeight - availableHeight)) / gridboards.length;
                }

                _.each(gridboards, function (gridboard) {
                    if (gridboard.rendered) {
                        var container = gridboard.up();
                        var prevEl = container.getEl().prev();
                        var containerHeaderHeight = gridboard.getEl().getTop() - (prevEl ? prevEl.getBottom() : appTop);
                        gridboard.setHeight(Math.max(minHeight, (availableHeight / gridboards.length) - containerHeaderHeight));
                    }
                });
            }
        }
    });
})();
(function () {
    var Ext = window.Ext4 || window.Ext;

    /**
     * A special cardboard card for use by the PortfolioKanbanApp
     */
    Ext.define('Rally.apps.portfoliokanban.PortfolioKanbanCard', {
        extend:'Rally.ui.cardboard.Card',
        alias:'widget.rallyportfoliokanbancard',

        inheritableStatics:{

            getFetchFields:function () {
                return [
                    'Owner',
                    'FormattedID',
                    'Name',
                    'StateChangedDate',
                    'Blocked',
                    'Ready',
                    'DisplayColor'
                ];
            }

        },

        config: {
            customFieldConfig: {
                UserStories: {
                    fetch: ['UserStories', 'LeafStoryPlanEstimateTotal', 'LeafStoryCount'],
                    popoverConfig: {
                        placement: ['bottom', 'right', 'left', 'top'],
                        listViewConfig: {
                            addNewConfig: {
                                showAddWithDetails: false
                            },
                            gridConfig: {
                                columnCfgs: [
                                    {
                                        dataIndex: 'FormattedID',
                                        width: 90
                                    },
                                    {
                                        dataIndex: 'Name',
                                        flex: 1
                                    },
                                    {
                                        dataIndex: 'Release',
                                        width: 90
                                    },
                                    {
                                        dataIndex: 'Iteration',
                                        width: 90
                                    },
                                    {
                                        dataIndex: 'ScheduleState', // 'dataIndex' is the actual field name
                                        text: 'State', // 'text' is the display name
                                        width: 90
                                    },
                                    {
                                        dataIndex: 'PlanEstimate',
                                        width: 90
                                    },
                                    {
                                        dataIndex: 'Project',
                                        width: 60
                                    }
                                ]
                            }
                        }
                    }
                }
            }
        },

        constructor: function(config) {
            config.fields = Ext.Array.union(config.fields || [], ['StateChangedDate']);
            this.callParent(arguments);
        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * @private
     * Shows the Kanban Policy for a Portfolio Item board, based on the State representing the column.
     * Used by the Rally.ui.cardboard.KanbanColumn
     */
    Ext.define('Rally.apps.portfoliokanban.PortfolioKanbanPolicy', {
        extend: 'Rally.ui.cardboard.PolicyContainer',
        alias: 'widget.rallyportfoliokanbanpolicy',

        config: {
            /**
             * @cfg {Rally.data.wsapi.Model} (required)
             * The Kanban State record that holds the policy information.
             */
            stateRecord: undefined
        },

        canEditPolicy: function() {
            return this.getStateRecord().get('updatable');
        },

        getPolicyText: function() {
            return this.getStateRecord() && this.getStateRecord().get('Description');
        },

        draw: function() {
            if (this.getStateRecord()) {
                this.callParent(arguments);
            } else {
                this._drawNotApplicable();
            }
        },

        _drawNotApplicable: function() {
            this.add({
                xtype: 'component',
                renderTpl: '<div class="policyContent">Not Applicable</div>'
            });
        },

        onEditClick: function() {
            Ext.create('Rally.ui.dialog.RichTextDialog', {
                title: 'Edit the Exit Policy for "' + this.getStateRecord().get('Name') + '" Column',
                headerItems: [
                    {
                        xtype: 'component',
                        cls: 'kanbanPolicyRichTextEditorHeader',
                        html: 'What needs to be done before an item is ready to leave this column?'
                    }
                ],
                autoShow: true,
                record: this.getStateRecord(),
                fieldName: 'Description',
                editorMaxHeight: 500,
                listeners: {
                    save: this.drawPolicy,
                    scope: this
                }
            });
        }
    });
})();
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Allows configuring of rows for the cardboard
     *
     *
     *      @example
     *      Ext.create('Ext.Container', {
     *          items: [{
     *              xtype: 'rowsettingsfield',
     *              value: {
     *                  show: true,
     *                  field: 'c_ClassofService'
     *              }
     *          }],
     *          renderTo: Ext.getBody().dom
     *      });
     *
     */
    Ext.define('Rally.apps.common.RowSettingsField', {
        alias: 'widget.rowsettingsfield',
        extend: 'Ext.form.FieldContainer',

        mixins: {
            field: 'Ext.form.field.Field'
        },

        layout: 'hbox',

        cls: 'row-settings',

        config: {
            /**
             * @cfg {Object}
             *
             * The row settings value for this field
             */
            value: undefined,

            /**
             * @cfg {Function}
             * A function which should return true if the specified field should
             * be included in the list of available swimlane fields
             * @param {Rally.data.wsapi.Field} field
             */
            isAllowedFieldFn: Ext.emptyFn,

            /**
             * @cfg {Object[]}
             *
             * Array of objects with name and value keys to be used by the row combobox
             * [{'name': 'Blocked', 'value': 'Blocked'},{'name': 'Owner', 'value': 'Owner'}]
             */
            explicitFields: [],

            /**
             * @cfg {String[]}
             * Array of models for which to list fields for
             */
            modelNames: [], //['userstory', 'defect'],

            /**
             * @cfg {String[]}
             * Array of field display names to show if found on at least 1 model, sortable and are not hidden
             */
            whiteListFields: []
        },

        initComponent: function() {
            this.callParent(arguments);

            this.mixins.field.initField.call(this);

            this.add([
                {
                    xtype: 'rallycheckboxfield',
                    name: 'showRows',
                    boxLabel: '',
                    margin: '0',
                    submitValue: false,
                    value: this.getValue().showRows,
                    listeners: {
                        change: function(checkbox, checked) {
                            this.down('rallycombobox').setDisabled(!checked);
                        },
                        scope: this
                    }
                },
                {
                    xtype: 'rallycombobox',
                    plugins: ['rallyfieldvalidationui'],
                    name: 'rowsField',
                    margin: '0 6px',
                    width: 130,
                    emptyText: 'Choose Field...',
                    displayField: 'name',
                    valueField: 'value',
                    disabled: this.getValue().showRows !== 'true',
                    editable: false,
                    submitValue: false,
                    storeType: 'Ext.data.Store',
                    storeConfig: {
                        remoteFilter: false,
                        fields: ['name', 'value'],
                        data: []
                    }
                }
            ]);

            this._loadModels();
        },
        _loadModels: function() {

            Rally.data.ModelFactory.getModels({
                types: this.getModelNames(),
                context: this.context,
                success: this._onModelsRetrieved,
                scope: this
            });
        },

        _onModelsRetrieved: function (models) {
            var fields = _.uniq(Ext.Array.merge(this.explicitFields, this._getRowableFields(_.values(models))), 'name');
            var combobox = this.down('rallycombobox');
            combobox.getStore().loadData(_.sortBy(fields, 'name'));
            combobox.setValue(this.getValue().rowsField);
            this.fireEvent('ready', this);
        },

        _getRowableFields: function (models) {
            var artifactModel = Rally.data.wsapi.ModelBuilder.buildCompositeArtifact(models, this.context),
                allFields = artifactModel.getFields(),
                rowableFields = _.filter(allFields, function (field) {
                    var attr = field.attributeDefinition;
                    return attr && !attr.Hidden && attr.Sortable &&
                        ((artifactModel.getModelsForField(field).length === models.length &&
                        this.isAllowedFieldFn(field)) || _.contains(this.whiteListFields, field.displayName));
                }, this);

            return _.map(rowableFields, function(field) {
                return {
                    name: field.displayName,
                    value: field.name
                };
            });
        },

        /**
         * When a form asks for the data this field represents,
         * give it the name of this field and the ref of the selected project (or an empty string).
         * Used when persisting the value of this field.
         * @return {Object}
         */
        getSubmitData: function() {
            var data = {},
                showField = this.down('rallycheckboxfield'),
                rowsField = this.down('rallycombobox'),
                showRows = showField.getValue() && !_.isEmpty(rowsField.getValue());
            data[showField.name] = showRows;
            if (showRows) {
                data[rowsField.name] = rowsField.getValue();
            }
            return data;
        },

        refreshWithNewModelType: function(type) {
            this.setModelNames([type]);
            this._loadModels();
        }
    });
})();
Ext.define('Rally.technicalservices.Settings', {
    singleton: true,
    requires: [
        'Rally.ui.combobox.FieldComboBox',
        'Rally.ui.combobox.ComboBox',
        'Rally.ui.CheckboxField'
    ],

    getFields: function (context, config, modelNames) {
        var labelWidth= 150;

        return [{
            name: 'groupHorizontallyByField',
            xtype: 'rowsettingsfield',
            fieldLabel: 'Swimlanes',
            margin: '10 0 10 0',
            mapsToMultiplePreferenceKeys: ['showRows', 'rowsField'],
            readyEvent: 'ready',
            labelWidth: labelWidth,
            whiteListFields: ['Parent'],
            modelNames: modelNames,
            isAllowedFieldFn: function (field) {
                var attr = field.attributeDefinition;
                return (attr.Custom && (attr.Constrained || attr.AttributeType.toLowerCase() !== 'string') ||
                    attr.Constrained || _.contains(['boolean'], attr.AttributeType.toLowerCase())) &&
                    !_.contains(['web_link', 'text', 'date'], attr.AttributeType.toLowerCase()) &&
                    !_.contains(['Archived', 'Portfolio Item Type', 'State'], attr.Name);
            }
        },{
            type: 'query',
            config: {
                plugins: [
                    {
                        ptype: 'rallyhelpfield',
                        helpId: 271
                    },
                    'rallyfieldvalidationui'
                ]
            }
        }];
    }
});
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350, 
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        console.log("_checkChecksum", container);
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if (! app.isExternal() ) {
                
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

(function () {
    var Ext = window.Ext4 || window.Ext;

    /**
     * PI Kanban Board App
     * Displays a cardboard and a type selector. Board shows States for the selected Type.
     */
    Ext.define('pfv-kanban', {
        extend: 'Rally.app.App',
        logger: new Rally.technicalservices.Logger(),
        appName: 'Portfolio Kanban',
        autoScroll: false,
        cls: 'portfolio-kanban',
        statePrefix: 'portfolio-kanban',
        toggleState: 'board',
        settingsScope: 'project',

        config: {
            defaultSettings: {
                fields: 'Discussion,PercentDoneByStoryCount,UserStories,Milestones',
                showScopeSelector: true,

            },
            selectorConfig: {
                renderInGridHeader: false
            }
        },

        mixins: [
            "Rally.clientmetrics.ClientMetricsRecordable"
        ],

        clientMetrics: [
            {
                method: '_showHelp',
                description: 'portfolio-kanban-show-help'
            }
        ],

        plugins: ['rallygridboardappresizer'],

        actionMenuItems: [],

        enableGridBoardToggle: false,
        enableAddNew: true,
        gridConfig: {},
        gridStoreConfig: {},
        addNewConfig: {},
        enableImport: true,
        enableCsvExport: true,
        enablePrint: true,
        enableRanking: true,
        isWorkspaceScoped: false,
        modelNames: [],
        modelsContext: null,
        printHeaderLabel: '',
        allowExpansionStateToBeSaved: true,
        initEvents: function() {
            this.callParent(arguments);
            this.addEvents(
                /**
                 * @event
                 * Fires after a gridboard has been added to the app.
                 * @param {Rally.ui.gridboard.GridBoard} gridboard
                 */
                'gridboardadded'
            );
        },
        launch: function () {
            this.addCls('portfolio-items-grid-board-app');
            if (Rally.environment.getContext().getSubscription().isModuleEnabled('Rally Portfolio Manager')) {
                this._loadGridBoardPreference();
                Rally.technicalservices.WsapiToolbox.fetchPortfolioItemTypes().then({
                    success: function(types){
                        this.portfolioItemTypes = types;
                        this._setupSelector();
                    },
                    scope: this
                });
            } else {
                this.add({
                    xtype: 'container',
                    html: '<div class="rpm-turned-off" style="padding: 50px; text-align: center;">You do not have RPM enabled for your subscription</div>'
                });
                this.publishComponentReady();
            }
        },
        _loadGridBoardPreference: function(){
            var gridboardPrefs = this.getSetting(this.getStateId('gridboard'));
            if (gridboardPrefs) {
                gridboardPrefs = Ext.JSON.decode(gridboardPrefs);
                this.toggleState = gridboardPrefs.toggleState || this.toggleState;
            }
        },
        _setupSelector: function(){
            this.logger.log('_setupSelector');
            if (this.gridboard){
                this.gridboard.destroy();
            }

            this.removeAll();

            this._addWaitingForSelectionContainer();
            this.subscribe(this, Rally.technicalservices.common.DashboardFilter.publishedEventName, this.updateDashboardFilter, this);
            this.publish(Rally.technicalservices.common.DashboardFilter.requestEventName, this);
        },
        _addWaitingForSelectionContainer: function(){

            var me = this;
            if (this.gridboard){
                this.gridboard.destroy();
            }

            this.gridboard = this.add({
                xtype: 'container',
                padding: 50,
                html: '<div class="message">No Dashboard Filter Selected. <a href="#">Try Again</a></div>',
                listeners: {
                    scope: this,
                    render: function(component) {
                        var link = component.getEl().down('a');
                        link.on('click', function(e) {
                            me.publish(Rally.technicalservices.common.DashboardFilter.requestEventName, this);
                        });
                    }
                }
            });
        },
        _getChildTypePath: function(parentType){
            var portfolioItemTypes = this.getPortfolioItemTypePathNames();
            this.logger.log('_getChildTypePath', parentType, portfolioItemTypes);
            var idx = _.indexOf(portfolioItemTypes, parentType.toLowerCase());
            if (idx > 0){
                return portfolioItemTypes[idx-1];
            }
            return null;
        },
        updateDashboardFilter: function(dashboardSettings){
            this.modelNames = [];
            this.currentChildType = null;

            if (!dashboardSettings){
                this._addWaitingForSelectionContainer();
                return;
            }

            var childTypePath = this._getChildTypePath(dashboardSettings.filterModelType);
            if (!childTypePath){
                this._addBlankGridboardMessage('Please select a ' + this.getPortfolioItemTypePathNames()[1] + ' or higher type of Portfolio Item to display its Portfolio Item children on this Kanban Board.');
                return;
            }

            this.logger.log('updateDashboardFilter', dashboardSettings, childTypePath);
            this.modelNames = [childTypePath];
            this.dashboardFilter = dashboardSettings;

            Rally.technicalservices.WsapiToolbox.fetchTypeDefinition(childTypePath).then({
                success: function(typeDefRecord){

                    this.currentChildType = typeDefRecord;
                    if(!this.rendered) {
                        this.on('afterrender', this.loadGridBoard, this, {single: true});
                    } else {
                        this.loadGridBoard();
                    }
                },
                failure: function(message){
                    Rally.ui.notify.Notifier.showError({message: message});
                },
                scope: this
            });


        },
        loadGridBoard: function () {

            if (this.gridboard) {
                this.gridboard.destroy();
            }
            this.logger.log('loadGridBoard', this.modelNames, this.currentChildType, this.gridboard);

            return Rally.data.ModelFactory.getModels({
                context: this.modelsContext || this.getContext(),
                types: this.modelNames,
                requester: this
            }).then({
                success: function (models) {
                    this.models = _.transform(models, function (result, value) {
                        result.push(value);
                    }, []);

                    this.modelNames = _.keys(models);

                    if(this.toggleState === 'board') {
                        return this.getCardBoardColumns().then({
                            success: function (columns) {
                                this.addGridBoard({
                                    columns: columns
                                });

                                if (!columns || columns.length === 0) {
                                    this.showNoColumns();
                                    this.publishComponentReady();
                                }
                            },
                            scope: this
                        });
                    } else {
                        this.addGridBoard();
                        this.publishComponentReady();
                    }
                },
                scope: this
            });
        },
        showNoColumns: function () {
            this.add({
                xtype: 'container',
                cls: 'no-type-text',
                html: '<p>This Type has no states defined.</p>'
            });
        },
        getCardBoardColumns: function () {
            return this._getStates().then({
                success: function (states) {
                    return this._buildColumns(states);
                },
                scope: this
            });
        },
        _buildColumns: function (states) {
            if (!states.length) {
                return undefined;
            }

            var columns = [
                {
                    columnHeaderConfig: {
                        headerTpl: 'No Entry'
                    },
                    value: null,
                    plugins: ['rallycardboardcollapsiblecolumns'].concat(this.getCardBoardColumnPlugins(null))
                }
            ];

            return columns.concat(_.map(states, function (state) {
                return {
                    value: state.get('_ref'),
                    wipLimit: state.get('WIPLimit'),
                    enableWipLimit: true,
                    columnHeaderConfig: {
                        record: state,
                        fieldToDisplay: 'Name',
                        editable: false
                    },
                    plugins: ['rallycardboardcollapsiblecolumns'].concat(this.getCardBoardColumnPlugins(state))
                };
            }, this));
        },
        _getStates: function () {
            var deferred = new Deft.Deferred();
            Ext.create('Rally.data.wsapi.Store', {
                model: Ext.identityFn('State'),
                context: this.getContext().getDataContext(),
                autoLoad: true,
                fetch: ['Name', 'WIPLimit', 'Description'],
                filters: [
                    {
                        property: 'TypeDef',
                        value: this.currentChildType.get('_ref')
                    },
                    {
                        property: 'Enabled',
                        value: true
                    }
                ],
                sorters: [
                    {
                        property: 'OrderIndex',
                        direction: 'ASC'
                    }
                ],
                listeners: {
                    load: function (store, records) {
                        deferred.resolve(records);
                    }
                }
            });
            return deferred.promise;
        },
        getPortfolioItemTypePathNames: function(){
            return _.map(this.portfolioItemTypes, function(t){ return t.typePath.toLowerCase(); });
        },
        getSettingsFields: function (context, config) {
            return Rally.technicalservices.Settings.getFields(this.getContext(), this.getSettings(), this.getPortfolioItemTypePathNames());
        },
        _addBlankGridboardMessage: function(message){
            if (this.gridboard){
                this.gridboard.destroy();
            }

            this.gridboard = this.add({
                xtype: 'container',
                padding: 50,
                html: Ext.String.format('<div class="message">{0}</div>',message),
            });
        },
        update: function(){
            alert('hhhh');
        },
        _createFilterItem: function(typeName, config) {
            return Ext.apply({
                xtype: typeName,
                margin: '-15 0 5 0',
                showPills: true,
                showClear: true
            }, config);
        },

        addGridBoard: function(options){

            this.gridboard = Ext.create('Rally.ui.gridboard.GridBoard', this.getGridBoardConfig(options));
            this.gridboard.on('filtertypeschange', this.onFilterTypesChange, this);

            this.add(this.gridboard);

            this.fireEvent('gridboardadded', this.gridboard);

            this.gridboard.getHeader().getRight().add([
                this._buildFilterInfo()
            ]);
        },
        getGridBoardPlugins: function () {

            return []
                .concat(this.enableAddNew ? [
                    {
                        ptype: 'rallygridboardaddnew',
                        context: this.getContext(),
                        addNewControlConfig: this.getAddNewConfig()
                    }
                ] : [])
                .concat([
                    _.merge({
                        ptype: 'rallygridboardcustomfiltercontrol',
                        containerConfig: {
                            width: 42
                        },
                        filterChildren: false,
                        filterControlConfig: _.merge({
                            margin: '3 9 3 0',
                            modelNames: this.modelNames,
                            stateful: true,
                            stateId: this.getScopedStateId('custom-filter-button')
                        }, this.getFilterControlConfig()),
                        ownerFilterControlConfig: {
                            stateful: true,
                            stateId: this.getScopedStateId('owner-filter')
                        },
                        showOwnerFilter: Rally.data.ModelTypes.areArtifacts(this.modelNames)
                    }, this.getGridBoardCustomFilterControlConfig()),
                    _.merge({
                        ptype: 'rallygridboardfieldpicker',
                        headerPosition: 'left'
                    }, this.getFieldPickerConfig())
                ])
                .concat([{
                    ptype: 'rallyboardpolicydisplayable',
                    pluginId: 'boardPolicyDisplayable',
                    prefKey: 'piKanbanPolicyChecked',
                    checkboxConfig: {
                        boxLabel: 'Show Policies',
                        margin: '2 5 5 5'
                    }
                }]);
        },

        getFilterControlConfig: function () {
            var config = {
                blackListFields: ['PortfolioItemType'],
                whiteListFields: ['Milestones']
            };

            return _.merge(config, {
                blackListFields: _.union(config.blackListFields, ['State'])
            });
        },
        getFieldPickerConfig: function () {
            var config = {
                gridFieldBlackList: Rally.ui.grid.FieldColumnFactory.getBlackListedFieldsForTypes(this.modelNames),
                boardFieldBlackList: [
                    'AcceptedLeafStoryCount',
                    'AcceptedLeafStoryPlanEstimateTotal',
                    'Blocker',
                    'DirectChildrenCount',
                    'LastUpdateDate',
                    'LeafStoryCount',
                    'LeafStoryPlanEstimateTotal',
                    'PortfolioItem',
                    'UnEstimatedLeafStoryCount'
                ],
                context: this.getContext()
            };

            return _.merge(config, {
                boardFieldBlackList: ['Predecessors', 'Successors'],
                margin: '3 9 14 0'
            });
        },
        getCardConfig: function () {
            return {
                xtype: 'rallyportfoliokanbancard'
            };
        },
        getCardBoardConfig: function (options) {
            options = options || {};
            var currentTypePath = this.currentChildType.get('TypePath');
            var filters = [];

            if (this.getSetting('query')) {
                try {
                    filters.push(Rally.data.QueryFilter.fromQueryString(this.getSetting('query')));
                } catch (e) {
                    Rally.ui.notify.Notifier.showError({ message: e.message });
                }
            }

            var config = {
                attribute: 'State',
                cardConfig: _.merge({
                    editable: true,
                    showColorIcon: true
                }, this.getCardConfig()),
                columnConfig: {
                    xtype: 'rallycardboardcolumn',
                    enableWipLimit: true,
                    fields: (this.getSetting('fields') || '').split(',')
                },
                columns: options.columns,
                ddGroup: currentTypePath,
                listeners: {
                    load: this.publishComponentReady,
                    cardupdated: this._publishContentUpdatedNoDashboardLayout,
                    scope: this
                },
                plugins: [{ ptype: 'rallyfixedheadercardboard' }],
                storeConfig: {
                    filters: filters,
                    context: this.getContext().getDataContext()
                },
                loadDescription: 'Portfolio Kanban'
            };

            if (this.getSetting('showRows') && this.getSetting('rowsField')) {
                Ext.apply(config, {
                    rowConfig: {
                        field: this.getSetting('rowsField'),
                        sortDirection: 'ASC'
                    }
                });
            }

            return config;
        },

        getCardBoardColumnPlugins: function (state) {
            var policyPlugin = this.gridboard && this.gridboard.getPlugin('boardPolicyDisplayable');

            return {
                ptype: 'rallycolumnpolicy',
                policyCmpConfig: {
                    xtype: 'rallyportfoliokanbanpolicy',
                    hidden: !policyPlugin,
                    title: 'Exit Policy',
                    stateRecord: state
                }
            };
        },

        publishComponentReady: function () {
            this.fireEvent('contentupdated', this);
            this.recordComponentReady();

            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
            Rally.environment.getMessageBus().publish(Rally.Message.piKanbanBoardReady);
        },

        _buildFilterInfo: function () {
            this.filterInfo = this.isFullPageApp ? null : Ext.create('Rally.ui.tooltip.FilterInfo', {
                projectName: this.getSetting('project') && this.getContext().get('project').Name || 'Following Global Project Setting',
                scopeUp: this.getSetting('projectScopeUp'),
                scopeDown: this.getSetting('projectScopeDown'),
                query: this.getSetting('query')
            });

            return this.filterInfo;
        },

        _publishContentUpdatedNoDashboardLayout: function () {
            this.fireEvent('contentupdated', { dashboardLayout: false });
        },

        getGridBoardConfig: function (options) {

            var filters = this.dashboardFilter && this.dashboardFilter.getFilter(this.currentChildType.get('TypePath'), this.portfolioItemTypes) || [];
            this.logger.log('getGridboardConfig', filters.toString(),this.currentChildType.get('TypePath'))
            return {
                itemId: 'gridboard',
                stateId: this.getStateId('gridboard'),
                toggleState: this.toggleState,
                modelNames: _.clone(this.modelNames),
                context: this._getGridBoardContext(),
                addNewPluginConfig: this.getAddNewConfig(),
                plugins: this.getGridBoardPlugins(options),
                cardBoardConfig: this.getCardBoardConfig(options),
                chartConfig: this.getChartConfig(),
                height: this.getHeight(),
                storeConfig: {
                    filters: filters
                }
            };
        },

        getStateId: function (suffix) {
            return this.statePrefix + (suffix ? '-' + suffix : '');
        },

        getScopedStateId: function (suffix) {
            return this.getContext().getScopedStateId(this.getStateId(suffix));
        },
        getChartConfig: function () {
            return {};
        },

        onFilterTypesChange: function() {},

        _shouldEnableRanking: function() {
            return this.enableRanking && Rally.data.ModelTypes.areArtifacts(this.modelNames) && this.getContext().getWorkspace().WorkspaceConfiguration.DragDropRankingEnabled;
        },
        getPermanentFilters: function() {
            return [];
        },

        getColumnCfgs: function() {
            return _.isEmpty(this.columnNames) ? Rally.ui.grid.FieldColumnFactory.getDefaultFieldsForTypes(this.modelNames) : this.columnNames;
        },

        getGridPlugins: function () {
            return [{
                ptype: 'rallytreegridexpandedrowpersistence',
                allowExpansionStateToBeSaved: this.allowExpansionStateToBeSaved
            }];
        },

        _getGridBoardContext: function () {
            return this.isWorkspaceScoped ? this.getContext().clone({ project: null }) : this.getContext();
        },

        getAddNewConfig: function () {
            return _.merge({
                context: this.getContext(),
                margin: '0 30 0 0',
                stateful: true,
                stateId: this.getScopedStateId('add-new')
            }, this.addNewConfig);
        },
        getGridBoardCustomFilterControlConfig: function () {
            return {};
        },
        getHeight: function () {
            var height = this.callParent(arguments);
            return Ext.isIE8 ? Math.max(height, 600) : height;
        },

        setHeight: function(height) {
            this.callParent(arguments);
            if(this.gridboard) {
                this.gridboard.setHeight(height);
            }
        },

        xmlExportEnabled: function(){
            return false;
        }
    });
})();
            
               Rally.launchApp('pfv-kanban', {
                   name: 'Portfolio Kanban'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
.message {
    font-family: ProximaNova, Helvetica, Arial;
    font-size: 14px;
    color: #999999;
}

.portfolio-item {
    font-family: ProximaNova, Helvetica, Arial;
    font-size: 14px;
    color: #666666;

}
    </style>

</head>
<body></body>
</html>